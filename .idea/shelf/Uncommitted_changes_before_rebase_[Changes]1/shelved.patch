Index: lib/features/common/presentation/utils/utils.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'dart:convert';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:crypto/crypto.dart';\nimport 'package:easy_debounce/easy_throttle.dart';\nimport 'package:emoji_extension/emoji_extension.dart' hide Color;\nimport 'package:encrypt/encrypt.dart' as encrypt;\nimport 'package:example/config/providers.dart';\nimport 'package:example/dependency/modal_bottom_sheet/modal_bottom_sheet.dart';\nimport 'package:example/dependency/toasty_box/model/toast_model.dart';\nimport 'package:example/dependency/toasty_box/toast_enums.dart';\nimport 'package:example/dependency/toasty_box/toast_item.dart';\nimport 'package:example/dependency/toasty_box/toast_service.dart';\nimport 'package:example/dependency/xen_popup_card/xen_popup_card.dart';\nimport 'package:example/features/common/domain/failures/failure.dart';\nimport 'package:example/features/common/presentation/utils/extensions/color_extension.dart';\nimport 'package:example/features/common/presentation/utils/extensions/platform_extension.dart';\nimport 'package:example/features/common/presentation/utils/extensions/ref_extension.dart';\nimport 'package:example/features/common/presentation/utils/extensions/ui_extension.dart';\nimport 'package:example/features/common/presentation/widgets/bottom_sheet_scroll_physics.dart';\nimport 'package:example/features/common/presentation/widgets/mobile_confirm_popup.dart';\nimport 'package:example/features/feedback/application/feedback_controller.dart';\nimport 'package:example/features/message/application/message_channel_list_controller.dart';\nimport 'package:example/features/message/domain/entities/message_member_entity.dart';\nimport 'package:example/features/message/presentation/widgets/message_user_and_group_tag_widget.dart';\nimport 'package:example/features/preference/presentation/screens/preference_screen.dart';\nimport 'package:flutter/cupertino.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:fpdart/fpdart.dart';\nimport 'package:http/http.dart' as http;\nimport 'package:image/image.dart' as image;\nimport 'package:intl/intl.dart';\nimport 'package:logger/logger.dart';\nimport 'package:tuple/tuple.dart';\nimport 'package:url_launcher/url_launcher.dart';\n\nclass Utils {\n  static GlobalKey<PreferenceScreenState> preferenceScreenKey = GlobalKey();\n\n  static late BuildContext mainContext;\n  static late WidgetRef ref;\n\n  static Future<T?> showPopupDialog<T>({\n    required Widget Function(ScrollController? scrollController) builder,\n    final Size? size,\n    final double? padding,\n    final bool? isMedia,\n    final bool? forcePopup,\n    final bool? isFlexibleHeightPopup,\n    final bool? disableEscapeClose,\n  }) async {\n    bool _isMedia = isMedia ?? false;\n    bool _forcePopup = forcePopup ?? false;\n    bool _isFlexibleHeightPopup = isFlexibleHeightPopup ?? false;\n    if (PlatformX.getIsDesktopView(Utils.mainContext) || _forcePopup) {\n      return showDialog<T>(\n        context: Utils.mainContext,\n        builder: (ctx) => XenPopupCard(\n          borderRadius: 0,\n          maxSize: size,\n          disableEscapeClose: disableEscapeClose,\n          cardBgColor: Colors.transparent,\n          padding: padding,\n          isMedia: _isMedia,\n          isFlexibleHeightPopup: _isFlexibleHeightPopup,\n          body: Center(\n            child: Padding(\n              padding: EdgeInsets.symmetric(\n                vertical: (MediaQueryData.fromView(View.of(Utils.mainContext)).size.height <= (size?.height ?? 560)) ? 16 : 0,\n                horizontal: (MediaQueryData.fromView(View.of(Utils.mainContext)).size.width <= (size?.width ?? 640)) ? 16 : 0,\n              ),\n              child: ClipRRect(\n                borderRadius: BorderRadius.circular(_isMedia ? 0 : 12),\n                child: Navigator(\n                  onGenerateRoute: (_) => CupertinoPageRoute(\n                    builder: (ctx) => Container(\n                      color: _isMedia ? Colors.transparent : ctx.outline,\n                      child: builder(null),\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      );\n    } else {\n      return CupertinoScaffold.showCupertinoModalBottomSheet<T>(\n        context: Utils.mainContext,\n        duration: kThemeAnimationDuration,\n        useRootNavigator: true,\n        barrierColor: Utils.mainContext.background,\n        builder: (context) => CupertinoScaffold(\n          topRadius: Radius.circular(20),\n          transitionBackgroundColor: context.background,\n          overlayStyle: context.brightness == Brightness.dark ? SystemUiOverlayStyle.light : SystemUiOverlayStyle.dark,\n          body: Navigator(\n            onGenerateRoute: (_) => CupertinoPageRoute(\n              builder: (ctx) => Material(\n                color: Colors.transparent,\n                child: Container(\n                  color: ctx.background,\n                  child: builder(ModalScrollController.of(context)),\n                ),\n              ),\n            ),\n          ),\n        ),\n      );\n    }\n  }\n\n  static Future<T?> showMobileConfirmPopup<T>({\n    required String title,\n    required String description,\n    required Future<void> Function() onPressConfirm,\n    String? cancelString,\n    String? confirmString,\n    bool? isWarning,\n  }) async {\n    return showPopupDialog(\n      forcePopup: true,\n      isFlexibleHeightPopup: true,\n      size: Size(320, 0),\n      builder: (_) => MobileConfirmPopup(\n        title: title,\n        description: description,\n        cancelString: cancelString ?? Utils.mainContext.tr.cancel,\n        confirmString: confirmString ?? Utils.mainContext.tr.ok,\n        isWarning: isWarning ?? false,\n        onPressConfirm: onPressConfirm,\n      ),\n    );\n  }\n\n  static String fromGoogleRRule(String rrule, DateTime startDate) {\n    final list = rrule.split(';');\n\n    // if (recurrence?.contains('RRULE:FREQ=MONTHLY') == true) {\n    //   if (!recurrence!.contains('BYDAY') && !recurrence.contains('BYMONTHDAY')) {\n    //     recurrence = '${recurrence};BYMONTHDAY=${(e.start?.date?.day ?? e.start?.dateTime?.day ?? 1)}';\n    //   }\n    // }\n    //\n    // if (recurrence?.contains('RRULE:FREQ=YEARLY') == true) {\n    //   if (!recurrence!.contains('BYDAY') && !recurrence.contains('BYMONTHDAY')) {\n    //     recurrence =\n    //     '${recurrence};BYMONTH=${(e.start?.date?.month ?? e.start?.dateTime?.month ?? 1)};BYMONTHDAY=${(e.start?.date?.day ?? e.start?.dateTime?.day ?? 1)}';\n    //   }\n    // }\n\n    if (rrule.contains('FREQ=MONTHLY')) {\n      final resultList = [];\n      String? weekDay;\n      String? number;\n\n      if (!rrule.contains('BYDAY') && !rrule.contains('BYMONTHDAY')) {\n        return '${rrule};BYMONTHDAY=${startDate.day}';\n      }\n\n      list.forEach((element) {\n        final key = element.split('=')[0];\n        final value = element.split('=')[1];\n        if (key == 'BYDAY') {\n          number = value.replaceAll(new RegExp(r'[^0-9]'), '');\n          weekDay = value.replaceAll(new RegExp(r'[(?!^0-9)]'), '');\n        } else {\n          resultList.add(element);\n        }\n\n        if (weekDay != null && number != null) {\n          if (number!.isEmpty) {\n            resultList.add('BYDAY=$weekDay');\n          } else {\n            resultList.add('BYDAY=$weekDay;BYSETPOS=$number');\n          }\n\n          weekDay = null;\n          number = null;\n        }\n      });\n\n      return resultList.join(';');\n    } else if (rrule.contains('FREQ=YEARLY')) {\n      if (!rrule.contains('BYDAY') && !rrule.contains('BYMONTHDAY')) {\n        return '${rrule};BYMONTH=${startDate.month};BYMONTHDAY=${startDate.day}';\n      }\n    }\n    return rrule;\n  }\n\n  static String toGoogleRRule(String rrule) {\n    final list = rrule.split(';');\n    if (rrule.contains('FREQ=MONTHLY')) {\n      final resultList = [];\n      String? weekDay;\n      String? number;\n\n      list.forEach((element) {\n        final key = element.split('=')[0];\n        final value = element.split('=')[1];\n        if (key == 'BYDAY') {\n          weekDay = value;\n        } else if (key == 'BYSETPOS') {\n          number = value;\n        } else {\n          resultList.add(element);\n        }\n\n        if (weekDay != null && number != null) {\n          resultList.add('BYDAY=$number$weekDay');\n          weekDay = null;\n          number = null;\n        }\n      });\n\n      return resultList.join(';');\n    } else if (rrule.contains('FREQ=YEARLY')) {}\n\n    return rrule;\n  }\n\n  static String generateBase32HexStringFromTimestamp() {\n    final timestamp = DateTime.now().millisecondsSinceEpoch;\n    final randomNumber = Random().nextInt(99999);\n    return '$timestamp$randomNumber';\n  }\n\n  static String encryptAESCryptoJS(String plainText, String passphrase) {\n    try {\n      final salt = genRandomWithNonZero(8);\n      var keyndIV = deriveKeyAndIV(passphrase, salt);\n      final key = encrypt.Key(keyndIV.item1);\n      final iv = encrypt.IV(keyndIV.item2);\n\n      final encrypter = encrypt.Encrypter(encrypt.AES(key, mode: encrypt.AESMode.cbc, padding: \"PKCS7\"));\n      final encrypted = encrypter.encrypt(plainText, iv: iv);\n      Uint8List encryptedBytesWithSalt = Uint8List.fromList(createUint8ListFromString(\"Salted__\") + salt + encrypted.bytes);\n      return base64.encode(encryptedBytesWithSalt);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  static String decryptAESCryptoJS(String encrypted, String passphrase) {\n    try {\n      Uint8List encryptedBytesWithSalt = base64.decode(encrypted);\n\n      Uint8List encryptedBytes = encryptedBytesWithSalt.sublist(16, encryptedBytesWithSalt.length);\n      final salt = encryptedBytesWithSalt.sublist(8, 16);\n      var keyndIV = deriveKeyAndIV(passphrase, salt);\n      final key = encrypt.Key(keyndIV.item1);\n      final iv = encrypt.IV(keyndIV.item2);\n\n      final encrypter = encrypt.Encrypter(encrypt.AES(key, mode: encrypt.AESMode.cbc, padding: \"PKCS7\"));\n      final decrypted = encrypter.decrypt64(base64.encode(encryptedBytes), iv: iv);\n      return decrypted;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  static Tuple2<Uint8List, Uint8List> deriveKeyAndIV(String passphrase, Uint8List salt) {\n    var password = createUint8ListFromString(passphrase);\n    Uint8List concatenatedHashes = Uint8List(0);\n    Uint8List currentHash = Uint8List(0);\n    bool enoughBytesForKey = false;\n    Uint8List preHash = Uint8List(0);\n\n    while (!enoughBytesForKey) {\n      if (currentHash.length > 0)\n        preHash = Uint8List.fromList(currentHash + password + salt);\n      else\n        preHash = Uint8List.fromList(password + salt);\n\n      currentHash = Uint8List.fromList(md5.convert(preHash).bytes);\n      concatenatedHashes = Uint8List.fromList(concatenatedHashes + currentHash);\n      if (concatenatedHashes.length >= 48) enoughBytesForKey = true;\n    }\n\n    var keyBtyes = concatenatedHashes.sublist(0, 32);\n    var ivBtyes = concatenatedHashes.sublist(32, 48);\n    return new Tuple2(keyBtyes, ivBtyes);\n  }\n\n  static Uint8List createUint8ListFromString(String s) {\n    var ret = new Uint8List(s.length);\n    for (var i = 0; i < s.length; i++) {\n      ret[i] = s.codeUnitAt(i);\n    }\n    return ret;\n  }\n\n  static Uint8List genRandomWithNonZero(int seedLength) {\n    final random = Random.secure();\n    const int randomMax = 245;\n    final Uint8List uint8list = Uint8List(seedLength);\n    for (int i = 0; i < seedLength; i++) {\n      uint8list[i] = random.nextInt(randomMax) + 1;\n    }\n    return uint8list;\n  }\n\n  static String durtaionFormatter(Duration d) {\n    var seconds = d.inSeconds;\n    final days = seconds ~/ Duration.secondsPerDay;\n    seconds -= days * Duration.secondsPerDay;\n    final hours = seconds ~/ Duration.secondsPerHour;\n    seconds -= hours * Duration.secondsPerHour;\n    final minutes = seconds ~/ Duration.secondsPerMinute;\n    seconds -= minutes * Duration.secondsPerMinute;\n\n    final List<String> tokens = [];\n\n    if (tokens.isNotEmpty || hours != 0) {\n      tokens.add('${hours}');\n    }\n    tokens.add('${minutes > 9 ? minutes.toString().padLeft(2, '0') : minutes}');\n    tokens.add('${seconds.toString().padLeft(2, '0')}');\n\n    return tokens.join(':');\n  }\n\n  static showBottomDialog({\n    required String title,\n    required Widget body,\n  }) {\n    showGeneralDialog(\n      context: Utils.mainContext,\n      barrierDismissible: true,\n      transitionDuration: Duration(milliseconds: 300),\n      transitionBuilder: (context, animation, secondaryAnimation, child) => FadeTransition(opacity: animation, child: child),\n      barrierLabel: MaterialLocalizations.of(Utils.mainContext).modalBarrierDismissLabel,\n      pageBuilder: (context, animation, secondaryAnimation) {\n        return SafeArea(\n          child: Padding(\n            padding: const EdgeInsets.only(left: 16, right: 16, bottom: 8),\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.end,\n              children: [\n                Material(\n                  color: Colors.transparent,\n                  child: Container(\n                    decoration: BoxDecoration(color: context.outline, borderRadius: BorderRadius.circular(16)),\n                    padding: const EdgeInsets.symmetric(vertical: 16),\n                    child: Column(\n                      children: [\n                        Padding(\n                          padding: const EdgeInsets.only(bottom: 16),\n                          child: Text(title, style: context.titleLarge?.textColor(context.outlineVariant).appFont(context).textBold),\n                        ),\n                        body\n                      ],\n                    ),\n                  ),\n                ),\n              ],\n            ),\n          ),\n        );\n      },\n    );\n  }\n\n  static showToast(ToastModel toast) {\n    ToastService.showWidgetToast(\n      Utils.mainContext,\n      isClosable: true,\n      backgroundColor: Colors.transparent,\n      shadowColor: Colors.transparent,\n      length: ToastLength.medium,\n      expandedHeight: 74,\n      width: PlatformX.getIsMobileView(Utils.mainContext) ? null : 280,\n      slideCurve: Curves.easeInOut,\n      positionCurve: Curves.easeInOut,\n      dismissDirection: DismissDirection.down,\n      builder: (index) {\n        return ToastItem(\n          item: toast,\n          onTapClose: () => ToastService.hideToast(index),\n        );\n      },\n    );\n  }\n\n  static showRateLimitedToast({required RateLimitType type}) {\n    showToast(ToastModel(message: TextSpan(text: type.getTitle(Utils.mainContext)), buttons: []));\n  }\n\n  static Future<bool> launchUrlExternal({required String? url}) async {\n    if (url == null) return false;\n    bool canLaunch = await canLaunchUrl(Uri.parse(url));\n\n    if (canLaunch) {\n      launchUrl(Uri.parse(url), mode: LaunchMode.externalApplication);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  static List<TextSpan> highlightSearchQuery({required TextStyle? defaultStyle, required String text, required String searchQuery}) {\n    Color highlightColor = Color(0xffffeb3b);\n\n    if (searchQuery.isEmpty) {\n      return [TextSpan(text: text, style: defaultStyle)];\n    }\n\n    final searchRegex = RegExp(RegExp.escape(searchQuery), caseSensitive: false);\n    final matches = searchRegex.allMatches(text);\n\n    List<TextSpan> spans = [];\n    int lastMatchEnd = 0;\n\n    for (final match in matches) {\n      if (match.start > lastMatchEnd) {\n        spans.add(TextSpan(text: text.substring(lastMatchEnd, match.start), style: defaultStyle));\n      }\n\n      spans.add(TextSpan(text: match.group(0), style: defaultStyle?.textColor(highlightColor)));\n\n      lastMatchEnd = match.end;\n    }\n\n    if (lastMatchEnd < text.length) {\n      spans.add(TextSpan(text: text.substring(lastMatchEnd), style: defaultStyle));\n    }\n\n    return spans;\n  }\n\n  static String getOrdinalSuffix(int day) {\n    if (!(day >= 1 && day <= 31)) {\n      throw ArgumentError('Invalid day of the month');\n    }\n    if (day >= 11 && day <= 13) return 'th';\n    switch (day % 10) {\n      case 1:\n        return 'st';\n      case 2:\n        return 'nd';\n      case 3:\n        return 'rd';\n      default:\n        return 'th';\n    }\n  }\n\n  // 링크와 코드 블럭을 처리하기 위한 정규표현식\n  static RegExp combinedRegex = RegExp(\n    r'\\*<((?:https?:\\/\\/[^\\s|>]+))(?:\\|([^>]*))?>\\*' + // 링크 굵게\n        r'|<((?:https?:\\/\\/[^\\s|>]+))\\s*(?:\\|([^>]*)\\s*)?>' + // 링크\n        r'|`<([^|>]+)\\|([^>]+)>`' + // 코드 블럭\n        r'|:([^:\\s]+):\\s*' + // 이모지\n        r'|~(.*?)~' + // 취소선\n        r'|_(.*?)_' + // 이탤릭\n        r'|\\*(.*?)\\*' + // 굵게\n        r'|<@([^>]+)>' + // 멘션\n        r'|<!date\\^(\\d+)\\^{([^>]+)}\\|([^>]+)>' + // 날짜\n        r'|`([^`]+)`' + // 마크 다운\n        r'|<#([^>]+)\\|>', //채널 멘션\n    dotAll: true,\n  );\n\n  static TextSpan slackTextToTextSpanConverter({\n    required String teamId,\n    required String channelId,\n    required TextStyle? defaultStyle,\n    required String text,\n    required String searchQuery,\n    required bool isMobileView,\n  }) {\n    List<InlineSpan> spans = [];\n    int lastMatchEnd = 0;\n    // 정규표현식을 통해 텍스트를 처리\n    final matches = combinedRegex.allMatches(text);\n\n    if (matches.isEmpty) {\n      spans.addAll(highlightSearchQuery(defaultStyle: defaultStyle, text: text, searchQuery: searchQuery));\n    } else {\n      for (final match in matches) {\n        if (match.start > lastMatchEnd) {\n          final substring = text.substring(lastMatchEnd, match.start);\n          spans.addAll(highlightSearchQuery(defaultStyle: defaultStyle, text: substring, searchQuery: searchQuery));\n        }\n\n        if (match.group(1) != null) {\n          // 링크 굵게 처리\n          final url = match.group(1)!;\n          final displayText = match.group(2) ?? match.group(1)!;\n          spans.add(\n            WidgetSpan(\n              child: GestureDetector(\n                onTap: isMobileView ? null : () => launchUrlExternal(url: url),\n                child: MouseRegion(\n                  cursor: isMobileView ? MouseCursor.defer : SystemMouseCursors.click,\n                  child: DefaultSelectionStyle(\n                    mouseCursor: SystemMouseCursors.click,\n                    child: isMobileView\n                        ? Text(textScaler: TextScaler.linear(1), displayText, style: defaultStyle?.textColor(mainContext.primary).textBold)\n                        : CustomPaint(\n                            painter: UnderlinePainter(displayText, defaultStyle!.textColor(mainContext.primary)),\n                            child:\n                                Text(textScaler: TextScaler.linear(1), displayText, style: defaultStyle.textColor(mainContext.primary).textUnderline.textBold)),\n                  ),\n                ),\n              ),\n            ),\n          );\n        }\n        if (match.group(3) != null) {\n          // 링크 처리\n          final url = match.group(3)!.trim();\n          final displayText = match.group(4)?.trim() ?? match.group(3)!.trim();\n\n          spans.add(\n            WidgetSpan(\n              child: GestureDetector(\n                onTap: isMobileView ? null : () => launchUrlExternal(url: url),\n                child: MouseRegion(\n                  cursor: isMobileView ? MouseCursor.defer : SystemMouseCursors.click,\n                  child: DefaultSelectionStyle(\n                    mouseCursor: SystemMouseCursors.click,\n                    child: isMobileView\n                        ? Text(textScaler: TextScaler.linear(1), displayText, style: defaultStyle?.textColor(mainContext.primary))\n                        : CustomPaint(\n                            painter: UnderlinePainter(displayText, defaultStyle!.textColor(mainContext.primary)),\n                            child: Text(textScaler: TextScaler.linear(1), displayText, style: defaultStyle.textColor(mainContext.primary)),\n                          ),\n                  ),\n                ),\n              ),\n            ),\n          );\n        } else if (match.group(5) != null) {\n          // 코드 블럭 처리\n          final url = match.group(5)!;\n          final displayText = match.group(6) ?? match.group(5)!;\n          spans.add(\n            WidgetSpan(\n              child: GestureDetector(\n                onTap: isMobileView ? null : () => launchUrlExternal(url: url),\n                child: MouseRegion(\n                  cursor: isMobileView ? MouseCursor.defer : SystemMouseCursors.click,\n                  child: DefaultSelectionStyle(\n                    mouseCursor: SystemMouseCursors.click,\n                    child: Text(\n                      textScaler: TextScaler.linear(1),\n                      displayText,\n                      style: defaultStyle?.textColor(Colors.orange),\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          );\n        } else if (match.group(7) != null) {\n          // 이모지 처리\n          final emojiText = match.group(7)!;\n          spans.add(TextSpan(text: Emojis.getOneOrNull(emojiText)?.value ?? ''));\n        } else if (match.group(8) != null) {\n          // 취소선 처리\n          final strikeText = match.group(8)!;\n          spans.add(TextSpan(\n            children: [\n              slackTextToTextSpanConverter(\n                  teamId: teamId,\n                  channelId: channelId,\n                  defaultStyle: defaultStyle?.copyWith(\n                    decoration: TextDecoration.lineThrough,\n                    decorationThickness: 3,\n                  ),\n                  text: strikeText,\n                  searchQuery: searchQuery,\n                  isMobileView: isMobileView)\n            ],\n          ));\n        } else if (match.group(9) != null) {\n          // 이탤릭 처리\n          final italicText = match.group(9)!;\n          spans.add(\n            TextSpan(\n              children: [\n                slackTextToTextSpanConverter(\n                    teamId: teamId,\n                    channelId: channelId,\n                    defaultStyle: defaultStyle?.copyWith(fontStyle: FontStyle.italic),\n                    text: italicText,\n                    searchQuery: searchQuery,\n                    isMobileView: isMobileView)\n              ],\n            ),\n          );\n        } else if (match.group(10) != null) {\n          // 굵게 처리\n          final boldText = match.group(10)!;\n          spans.add(TextSpan(\n            children: [\n              slackTextToTextSpanConverter(\n                  teamId: teamId,\n                  channelId: channelId,\n                  defaultStyle: defaultStyle?.copyWith(fontWeight: FontWeight.bold),\n                  text: boldText,\n                  searchQuery: searchQuery,\n                  isMobileView: isMobileView)\n            ],\n          ));\n        } else if (match.group(11) != null) {\n          // 멘션 처리\n          final mentionText = match.group(11)!;\n          final channelData = ref.readIfExists(messageChannelListControllerProvider)?.value ?? {};\n          final channels = [...(channelData.values.expand((e) => e))];\n          final channel = channels.firstWhereOrNull((e) => e.id == channelId);\n          MessageMemberEntity? member = channel?.members.where((m) => m.id == mentionText).firstOrNull;\n\n          spans.add(\n            WidgetSpan(\n              child: MessageUserAndGroupTagWidget(\n                defaultStyle: defaultStyle!.copyWith(decoration: TextDecoration.none),\n                isGroup: false,\n                isMe: false,\n                name: member?.displayName ?? '',\n              ),\n            ),\n          );\n        } else if (match.group(12) != null && match.group(13) != null && match.group(14) != null) {\n          final timestamp = int.parse(match.group(12)!);\n          final formatString = match.group(13)!;\n          final fallbackText = match.group(14)!;\n\n          bool isTime = formatString == 'time';\n          bool isDateShort = formatString == 'date_short_pretty';\n          bool isDateLong = formatString == 'date_long_pretty';\n\n          // Unix 타임스탬프를 DateTime으로 변환\n          final date = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);\n\n          // 형식에 맞춰 날짜를 표시\n          final formattedDate = isTime\n              ? DateFormat('hh:mm a').format(date)\n              : isDateShort\n                  ? DateFormat('MMM d').format(date)\n                  : isDateLong\n                      ? DateFormat('EEEE, MMMM d').format(date) + getOrdinalSuffix(date.day)\n                      : fallbackText;\n\n          spans.add(TextSpan(\n            text: ' ${formattedDate} ',\n            style: defaultStyle,\n          ));\n        } else if (match.group(15) != null) {\n          // 마크 다운 처리\n          final displayText = match.group(15)!;\n          spans.add(\n            TextSpan(\n              text: displayText,\n              style: defaultStyle?.textColor(Colors.orange),\n            ),\n          );\n        } else if (match.group(16) != null) {\n          // 채널 멘션 처리\n          final channelText = match.group(16)!;\n          final channelData = ref.readIfExists(messageChannelListControllerProvider)?.value ?? {};\n          final channels = [...(channelData.values.expand((e) => e))];\n          final channel = channels.firstWhereOrNull((e) => e.id == channelText);\n          spans.add(\n            TextSpan(\n              text: '#${channel?.displayName}',\n              style: defaultStyle?.textColor(Colors.blue).copyWith(backgroundColor: Colors.blue.withValues(alpha:0.2)),\n            ),\n          );\n        }\n\n        lastMatchEnd = match.end;\n      }\n      // 마지막 매치 이후의 텍스트 처리\n      if (lastMatchEnd < text.length) {\n        spans.addAll(highlightSearchQuery(defaultStyle: defaultStyle, text: text.substring(lastMatchEnd), searchQuery: searchQuery));\n      }\n    }\n\n    return TextSpan(children: spans, style: defaultStyle);\n  }\n\n  static String slackPretextToStringConverter({required String teamId, required String channelId, required String text, required bool showMentionTag}) {\n    List<String> strings = [];\n    int lastMatchEnd = 0;\n\n    // 정규표현식을 통해 텍스트를 처리\n    final matches = combinedRegex.allMatches(text);\n\n    for (final match in matches) {\n      if (match.start > lastMatchEnd) {\n        final substring = text.substring(lastMatchEnd, match.start);\n        strings.add(substring);\n      }\n\n      if (match.group(1) != null) {\n        // 링크 굵게 처리\n        final displayText = match.group(2) ?? match.group(1)!;\n        strings.add(displayText);\n      } else if (match.group(3) != null) {\n        // 링크 처리\n        final displayText = match.group(4) ?? match.group(3)!;\n        strings.add(displayText);\n      } else if (match.group(5) != null) {\n        // 코드 블럭 처리\n        final displayText = match.group(6) ?? match.group(5)!;\n        strings.add(displayText);\n      } else if (match.group(7) != null) {\n        // 이모지 처리\n        final emojiText = match.group(7)!;\n        strings.add(Emojis.getOneOrNull(emojiText)?.value ?? '');\n      } else if (match.group(8) != null) {\n        // 취소선 처리\n        final strikeText = match.group(8)!;\n        strings.add(strikeText);\n      } else if (match.group(9) != null) {\n        // 이탤릭 처리\n        final italicText = match.group(9)!;\n        strings.add(italicText);\n      } else if (match.group(10) != null) {\n        // 굵게 처리\n        final boldText = match.group(10)!;\n        strings.add(boldText);\n      } else if (match.group(11) != null) {\n        // 멘션 처리\n        final mentionText = match.group(11)!;\n        final channelData = ref.readIfExists(messageChannelListControllerProvider)?.value ?? {};\n        final channels = [...(channelData.values.expand((e) => e))];\n        final channel = channels.firstWhereOrNull((e) => e.id == channelId);\n        MessageMemberEntity? member = channel?.members.where((m) => m.id == mentionText).firstOrNull;\n        strings.add('${showMentionTag ? '@' : ''}${member?.displayName}');\n      } else if (match.group(12) != null && match.group(13) != null && match.group(14) != null) {\n        final timestamp = int.parse(match.group(12)!);\n        final formatString = match.group(13)!;\n        final fallbackText = match.group(14)!;\n\n        bool isTime = formatString == 'time';\n        bool isDateShort = formatString == 'date_short_pretty';\n        bool isDateLong = formatString == 'date_long_pretty';\n\n        // Unix 타임스탬프를 DateTime으로 변환\n        final date = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);\n\n        // 형식에 맞춰 날짜를 표시\n        final formattedDate = isTime\n            ? DateFormat('hh:mm a').format(date)\n            : isDateShort\n                ? DateFormat('MMM d').format(date)\n                : isDateLong\n                    ? DateFormat('EEEE, MMMM d').format(date) + getOrdinalSuffix(date.day)\n                    : fallbackText;\n\n        strings.add(' ${formattedDate} ');\n      } else if (match.group(15) != null) {\n        // 마크 다운 처리\n        final displayText = match.group(15)!;\n        strings.add(displayText);\n      } else if (match.group(16) != null) {\n        // 채널 멘션 처리\n        final channelText = match.group(16)!;\n        final channelData = ref.readIfExists(messageChannelListControllerProvider)?.value ?? {};\n        final channels = [...(channelData.values.expand((e) => e))];\n        final channel = channels.firstWhereOrNull((e) => e.id == channelText);\n        strings.add('${showMentionTag ? '#' : ''}${channel?.displayName}');\n      }\n\n      lastMatchEnd = match.end;\n    }\n\n    // 마지막 매치 이후의 텍스트 처리\n    if (lastMatchEnd < text.length) {\n      strings.add(text.substring(lastMatchEnd));\n    }\n\n    return strings.join('');\n  }\n\n  static Future<Uint8List?> getNotificationImage({required String? imageUrl, required String providerPath}) async {\n    final providerLogo = await assetImageToFilePath(providerPath);\n    if (imageUrl == null) {\n      return providerLogo;\n    }\n    try {\n      final profileImage = await networkImageToFilePath(imageUrl);\n      if (profileImage == null) {\n        return providerLogo;\n      } else {\n        image.Image profileIcon = image.decodeImage(profileImage)!;\n        image.Image profile = image.Image(\n          width: profileIcon.width,\n          height: profileIcon.height,\n          numChannels: 4,\n          backgroundColor: image.ColorUint8.rgba(0, 0, 0, 0),\n        );\n        image.compositeImage(profile, profileIcon);\n        profile = image.copyResizeCropSquare(\n          profile,\n          size: 1024,\n          radius: 340,\n          antialias: true,\n          interpolation: image.Interpolation.linear,\n        );\n\n        image.Image whiteImage = image.fill(\n          image.Image(\n            width: 420,\n            height: 420,\n            numChannels: 4,\n            backgroundColor: image.ColorUint8.rgba(0, 0, 0, 0),\n          ),\n          color: image.ColorUint8.rgba(255, 255, 255, 255),\n        );\n        image.Image providerIcon = image.decodeImage(providerLogo)!;\n\n        whiteImage = image.copyResizeCropSquare(\n          whiteImage,\n          size: 420,\n          radius: 210,\n          antialias: true,\n          interpolation: image.Interpolation.linear,\n        );\n\n        providerIcon = image.copyResizeCropSquare(\n          providerIcon,\n          size: 260,\n          radius: 0,\n          antialias: true,\n          interpolation: image.Interpolation.linear,\n        );\n\n        final providerWithBackgroundImage = image.Image(\n          width: whiteImage.width,\n          height: whiteImage.height,\n          numChannels: 4,\n          backgroundColor: image.ColorUint8.rgba(0, 0, 0, 0),\n        );\n        image.compositeImage(providerWithBackgroundImage, whiteImage);\n        image.compositeImage(providerWithBackgroundImage, providerIcon, center: true);\n\n        final mergedImage = image.Image(\n          width: 1024,\n          height: 1024,\n          numChannels: 4,\n          backgroundColor: image.ColorUint8.rgba(0, 0, 0, 0),\n        );\n\n        image.compositeImage(\n          mergedImage,\n          profile,\n          dstX: 0,\n          dstY: 0,\n          dstW: (profile.width * 0.9).floor(),\n          dstH: (profile.height * 0.9).floor(),\n        );\n\n        image.compositeImage(\n          mergedImage,\n          providerWithBackgroundImage,\n          dstX: (profile.width * 4 / 7).floor(),\n          dstY: (profile.height * 5 / 9).floor(),\n          dstW: (profile.width * 3 / 7).floor(),\n          dstH: (profile.height * 3 / 7).floor(),\n        );\n\n        return image.encodePng(mergedImage);\n      }\n    } catch (e) {\n      return providerLogo;\n    }\n  }\n\n  static Future<Uint8List> assetImageToFilePath(String asset) async {\n    final ByteData byteData = await rootBundle.load(asset);\n    return byteData.buffer.asUint8List(byteData.offsetInBytes, byteData.lengthInBytes);\n  }\n\n  static Future<Uint8List?> networkImageToFilePath(String imageUrl) async {\n    try {\n      final http.Response response = await http.get(Uri.parse(imageUrl));\n      return response.bodyBytes;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  static void focusApp({FocusNode? focusNode, bool? doNotFocus, bool? forceReset}) {\n    if (forceReset != true) {\n      if (((HardwareKeyboard.instance.logicalKeysPressed.length == 1 || HardwareKeyboard.instance.logicalKeysPressed.length == 2) &&\n          (HardwareKeyboard.instance.isAltPressed ||\n              HardwareKeyboard.instance.isControlPressed ||\n              HardwareKeyboard.instance.isMetaPressed ||\n              HardwareKeyboard.instance.isShiftPressed))) return;\n\n      if (FocusManager.instance.primaryFocus != mainFocus && !PlatformX.isWindows) {\n        if ((FocusManager.instance.primaryFocus?.hasFocus == true && FocusManager.instance.primaryFocus?.children.isNotEmpty != true)) {\n          return;\n        }\n      }\n    }\n\n    VoidCallback resetData = () {\n      // ignore: invalid_use_of_visible_for_testing_member, deprecated_member_use\n      ServicesBinding.instance.keyEventManager.clearState();\n      // ignore: invalid_use_of_visible_for_testing_member\n      ServicesBinding.instance.keyboard.clearState();\n      // HardwareKeyboard.instance.syncKeyboardState();\n      keyboardResetNotifier.value = Random().nextInt(100000);\n\n      if (doNotFocus == true) return;\n\n      (focusNode ?? FocusManager.instance.primaryFocus ?? mainFocus).requestFocus();\n    };\n\n    if (forceReset == true) {\n      EasyThrottle.cancel('keyboard_reattach');\n      resetData();\n    }\n\n    EasyThrottle.throttle('keyboard_reattach', Duration(milliseconds: 250), () {\n      resetData();\n    });\n  }\n\n  static Future<void> reportAutoFeedback({required String errorMessage}) async {\n    await Utils.ref.readNotifierIfExists(feedbackControllerProvider)?.upsertAutoFeedback(errorMessage: errorMessage);\n  }\n}\n\nFocusNode mainFocus = FocusNode();\n\nEither<Failure, R> debugLeft<L, R>(Object error) {\n  Logger().e(error, stackTrace: StackTrace.current);\n  return left(Failure.badRequest(StackTrace.current, error.toString()));\n}\n\nString getColorString(BuildContext context, String? colorString) {\n  if (colorString == null) return '';\n  if (ColorX.fromHex(colorString) == Colors.red.shade500) return context.tr.mail_pref_account_color_red;\n  if (ColorX.fromHex(colorString) == Colors.deepOrange.shade500) return context.tr.mail_pref_account_color_deep_orange;\n  if (ColorX.fromHex(colorString) == Colors.orange.shade500) return context.tr.mail_pref_account_color_orange;\n  if (ColorX.fromHex(colorString) == Colors.yellow.shade500) return context.tr.mail_pref_account_color_yellow;\n  if (ColorX.fromHex(colorString) == Colors.lightGreen.shade500) return context.tr.mail_pref_account_color_light_green;\n  if (ColorX.fromHex(colorString) == Colors.green.shade500) return context.tr.mail_pref_account_color_green;\n  if (ColorX.fromHex(colorString) == Colors.teal.shade500) return context.tr.mail_pref_account_color_teal;\n  if (ColorX.fromHex(colorString) == Colors.lightBlue.shade500) return context.tr.mail_pref_account_color_light_blue;\n  if (ColorX.fromHex(colorString) == Colors.indigo.shade500) return context.tr.mail_pref_account_color_indigo;\n  if (ColorX.fromHex(colorString) == Colors.deepPurple.shade500) return context.tr.mail_pref_account_color_deep_purple;\n  if (ColorX.fromHex(colorString) == Colors.purple.shade500) return context.tr.mail_pref_account_color_purple;\n  if (ColorX.fromHex(colorString) == Colors.brown.shade500) return context.tr.mail_pref_account_color_brown;\n  return '';\n}\n\nString getTimeString(BuildContext context, int? minute) {\n  if (minute == 15) return '15 ${context.tr.minutes.toLowerCase()}';\n  if (minute == 30) return '30 ${context.tr.minutes.toLowerCase()}';\n  if (minute == 45) return '45 ${context.tr.minutes.toLowerCase()}';\n  if (minute == 60) return '1 ${context.tr.hour.toLowerCase()}';\n  if (minute == 90) return '1 ${context.tr.hour.toLowerCase()} 30 ${context.tr.minutes.toLowerCase()}';\n  if (minute == 120) return '2 ${context.tr.hours.toLowerCase()}';\n  return '';\n}\n\nScrollPhysics Utils.getScrollPhysicsForBottomSheet(ScrollController? scr) {\n  if (scr != null) {\n    SchedulerBinding.instance.addPostFrameCallback((_) {\n      scr.position.isScrollingNotifier.addListener(() {\n        final position = scr.position;\n        if (!position.isScrollingNotifier.value) {\n          ModalBottomSheet.isDismissible = true;\n        } else {\n          if (position.pixels <= 0) {\n            ModalBottomSheet.isDismissible = true;\n          } else {\n            ModalBottomSheet.isDismissible = false;\n          }\n        }\n      });\n    });\n\n    return BottomSheetScrollPhysics();\n  }\n  return BouncingScrollPhysics();\n}\n\nenum RateLimitType { slack, gmail, gcalendar }\n\nextension RateLimitTypeX on RateLimitType {\n  String getTitle(BuildContext context) {\n    switch (this) {\n      case RateLimitType.slack:\n        return context.tr.message_slack_api_limit_reached;\n      case RateLimitType.gcalendar:\n        return context.tr.calendar_google_api_limit_reached;\n      case RateLimitType.gmail:\n        return context.tr.mail_google_api_limit_reached;\n    }\n  }\n}\n\nclass ConsistentUnderlineText extends StatelessWidget {\n  final String text;\n  final TextStyle style;\n\n  ConsistentUnderlineText({required this.text, required this.style});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: UnderlinePainter(text, style),\n      child: Text(text, style: style),\n    );\n  }\n}\n\nclass UnderlinePainter extends CustomPainter {\n  final String text;\n  final TextStyle style;\n\n  UnderlinePainter(this.text, this.style);\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final textPainter = TextPainter(\n      text: TextSpan(text: text, style: style),\n      textDirection: ui.TextDirection.ltr,\n      textAlign: TextAlign.left,\n    )..layout(maxWidth: size.width);\n\n    final underlineHeight = style.fontSize! * 0.05; // 밑줄 높이 조절\n    final paint = Paint()..color = style.color!;\n\n    for (var line in textPainter.computeLineMetrics()) {\n      final underlineY = line.baseline + underlineHeight;\n\n      canvas.drawRect(\n        Rect.fromLTWH(0, underlineY, line.width, underlineHeight),\n        paint,\n      );\n    }\n\n    textPainter.paint(canvas, Offset.zero);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/features/common/presentation/utils/utils.dart b/lib/features/common/presentation/utils/utils.dart
--- a/lib/features/common/presentation/utils/utils.dart	(revision 673cc0472510a3c4898d4afc4f6ba3316d0c2fcd)
+++ b/lib/features/common/presentation/utils/utils.dart	(date 1737790334404)
@@ -936,6 +936,7 @@
 
 Either<Failure, R> debugLeft<L, R>(Object error) {
   Logger().e(error, stackTrace: StackTrace.current);
+  Utils.reportAutoFeedback(errorMessage: error.toString());
   return left(Failure.badRequest(StackTrace.current, error.toString()));
 }
 
Index: lib/features/calendar/infrastructure/datasources/remote/google_calendar_datasource.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'dart:convert';\n\nimport 'package:example/features/auth/domain/entities/notification_entity.dart';\nimport 'package:example/features/auth/domain/entities/user_entity.dart';\nimport 'package:example/features/calendar/domain/datasources/calendar_datasource.dart';\nimport 'package:example/features/calendar/domain/entities/calendar_entity.dart';\nimport 'package:example/features/calendar/domain/entities/calendar_reminder_entity.dart';\nimport 'package:example/features/calendar/domain/entities/event_attendee_entity.dart';\nimport 'package:example/features/calendar/domain/entities/event_entity.dart';\nimport 'package:example/features/calendar/domain/entities/event_reminder_entity.dart';\nimport 'package:example/features/common/infrastructure/entities/environment.dart';\nimport 'package:example/features/common/presentation/utils/extensions/list_extension.dart';\nimport 'package:example/features/common/presentation/utils/google_api_handler.dart';\nimport 'package:example/features/common/presentation/utils/utils.dart';\nimport 'package:example/features/preference/domain/entities/local_pref_entity.dart';\nimport 'package:example/features/preference/domain/entities/oauth_entity.dart';\nimport 'package:example/flavors.dart';\nimport 'package:flutter/services.dart';\nimport 'package:googleapis/calendar/v3.dart' as GoogleCalendar;\nimport 'package:googleapis/people/v1.dart' as GooglePeople;\nimport 'package:http/http.dart' as http;\nimport 'package:queue/queue.dart';\n\nclass GoogleCalendarDatasource implements CalendarDatasource {\n  GoogleCalendarDatasource();\n\n  Queue _queue = Queue();\n\n  static List<String> scopes = [\n    GoogleCalendar.CalendarApi.calendarScope,\n    GooglePeople.PeopleServiceApi.contactsReadonlyScope,\n    GooglePeople.PeopleServiceApi.userinfoProfileScope,\n    GooglePeople.PeopleServiceApi.userinfoEmailScope,\n  ];\n\n  List<GoogleCalendar.Channel> channels = [];\n\n  @override\n  Future<OAuthEntity?> integrate() async {\n    final oauth = await GoogleApiHandler.integrate(scopes, 'calendar');\n    return oauth;\n  }\n\n  @override\n  Future<Map<String, List<CalendarEntity>>> fetchCalendarLists({Map<String, http.Client>? clients, required LocalPrefEntity pref}) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google);\n\n    Map<String, List<CalendarEntity>> calendars = {};\n\n    for (OAuthEntity oauth in googleOAuths) {\n      final client = clients != null ? clients[oauth.email] : await GoogleApiHandler.getClient(oauth: oauth, scope: scopes);\n      if (client != null) {\n        try {\n          final value = await _queue.add(() => GoogleCalendar.CalendarApi(client).calendarList.list());\n          final result = value.items\n                  ?.map((e) {\n                    if (e.id != null && e.backgroundColor != null && e.foregroundColor != null && e.summary != null) {\n                      return CalendarEntity(\n                        id: e.id!,\n                        name: e.summary!,\n                        backgroundColor: e.backgroundColor!,\n                        foregroundColor: e.foregroundColor!,\n                        email: oauth.email,\n                        owned: e.accessRole == \"owner\",\n                        modifiable: e.accessRole == \"owner\" || e.accessRole == \"writer\",\n                        type: CalendarEntityType.google,\n                        defaultReminders: e.defaultReminders?.map((e) => EventReminderEntityX.fromGoogleEntity(e)).toList(),\n                      );\n                    } else {\n                      return null;\n                    }\n                  })\n                  .whereType<CalendarEntity>()\n                  .toList() ??\n              [];\n\n          calendars[oauth.email] = result;\n        } catch (e) {\n          GoogleApiHandler.checkAuthNotWork(oauth, e.toString(), isCalendar: true);\n          throw e;\n        }\n      }\n    }\n\n    return calendars;\n  }\n\n  @override\n  Future<List<EventEntity>> fetchEventLists({\n    required DateTime startDateTime,\n    required DateTime endDateTime,\n    required LocalPrefEntity pref,\n    required List<CalendarEntity> calendars,\n    String? nextPageToken,\n  }) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    Map<String, http.Client> clients = {};\n    final authResult = await Future.wait(googleOAuths.map((e) => GoogleApiHandler.getClient(oauth: e, scope: scopes)));\n    for (int i = 0; i < authResult.length; i++) {\n      clients[googleOAuths[i].email] = authResult[i];\n    }\n\n    final result = await _queue.add(() => Future.wait(calendars.map((calendar) => fetchEventsInCalendar(\n        googleOAuths.where((o) => o.email == calendar.email).first, clients[calendar.email], calendar, startDateTime, endDateTime, nextPageToken, pref))));\n\n    return result.expand((element) => element).toList();\n  }\n\n  @override\n  Future<EventEntity?> getInstnace({\n    http.Client? client,\n    required DateTime startDateTime,\n    required LocalPrefEntity pref,\n    required String recurringEventId,\n    required CalendarEntity calendar,\n  }) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    if (client == null) {\n      Map<String, http.Client> clients = {};\n      final authResult = await Future.wait(googleOAuths.map((e) => GoogleApiHandler.getClient(oauth: e, scope: scopes)));\n      for (int i = 0; i < authResult.length; i++) {\n        clients[googleOAuths[i].email] = authResult[i];\n      }\n\n      client = clients[calendar.email];\n      if (client == null) return null;\n\n      try {\n        GoogleCalendar.Events value = await _queue.add(() => GoogleCalendar.CalendarApi(client!).events.instances(\n              calendar.id,\n              recurringEventId,\n              timeMin: startDateTime,\n              timeMax: startDateTime.add(Duration(minutes: 1)),\n            ));\n\n        return value.items?.isNotEmpty == true ? EventEntity.fromGoogleEvent(calendar: calendar, googleEvent: value.items!.first) : null;\n      } catch (e) {\n        GoogleApiHandler.checkAuthNotWork(googleOAuths.where((o) => o.email == calendar.email).first, e.toString(), isCalendar: true);\n        throw e;\n      }\n    } else {\n      try {\n        GoogleCalendar.Events value = await _queue.add(() => GoogleCalendar.CalendarApi(client!).events.instances(\n              calendar.id,\n              recurringEventId,\n              timeMin: startDateTime,\n              timeMax: startDateTime.add(Duration(minutes: 1)),\n            ));\n\n        return value.items?.isNotEmpty == true ? EventEntity.fromGoogleEvent(calendar: calendar, googleEvent: value.items!.first) : null;\n      } catch (e) {\n        GoogleApiHandler.checkAuthNotWork(googleOAuths.where((o) => o.email == calendar.email).first, e.toString(), isCalendar: true);\n        throw e;\n      }\n    }\n  }\n\n  @override\n  Future<List<EventEntity>> lazyFetchEventsInCalendar({\n    http.Client? client,\n    required DateTime startDateTime,\n    required DateTime endDateTime,\n    required LocalPrefEntity pref,\n    required CalendarEntity calendar,\n    String? nextPageToken,\n  }) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    if (client == null) {\n      Map<String, http.Client> clients = {};\n      final authResult = await Future.wait(googleOAuths.map((e) => GoogleApiHandler.getClient(oauth: e, scope: scopes)));\n      for (int i = 0; i < authResult.length; i++) {\n        clients[googleOAuths[i].email] = authResult[i];\n      }\n\n      client = clients[calendar.email];\n      final result = await _queue.add(() =>\n          fetchEventsInCalendar(googleOAuths.where((o) => o.email == calendar.email).first, client, calendar, startDateTime, endDateTime, nextPageToken, pref));\n      return result;\n    } else {\n      final result = await _queue.add(() =>\n          fetchEventsInCalendar(googleOAuths.where((o) => o.email == calendar.email).first, client, calendar, startDateTime, endDateTime, nextPageToken, pref));\n      return result;\n    }\n  }\n\n  @override\n  Future<EventEntity?> responseInvitation(\n    EventEntity event,\n    EventAttendeeEntity attendee,\n    CalendarEntity? originalCalendar,\n    LocalPrefEntity pref,\n  ) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    final oauth = googleOAuths.firstWhere((element) => element.email == event.calendarAuthMail);\n    final client = await GoogleApiHandler.getClient(oauth: oauth, scope: scopes);\n\n    try {\n      GoogleCalendar.Event value = await _queue.add(() => GoogleCalendar.CalendarApi(client).events.patch(\n            GoogleCalendar.Event(attendees: [attendee.toGoogleCalendarEventAttendee()]),\n            originalCalendar?.id ?? event.calendarId,\n            event.eventId,\n            alwaysIncludeEmail: true,\n            sendUpdates: \"all\",\n            conferenceDataVersion: event.conferenceData != null ? 1 : null,\n          ));\n\n      if (event.calendarId != originalCalendar?.id && originalCalendar?.id != null) {\n        value = await _queue.add(() => GoogleCalendar.CalendarApi(client).events.move(\n              originalCalendar!.id,\n              value.id!,\n              event.calendarId,\n            ));\n      }\n\n      return EventEntity.fromGoogleEvent(\n        calendar: event.calendar,\n        googleEvent: value.copyWith(\n          start: event.googleEvent!.start,\n          end: event.googleEvent!.end,\n        ),\n      );\n    } catch (e) {\n      GoogleApiHandler.checkAuthNotWork(oauth, e.toString(), isCalendar: true);\n      throw e;\n    }\n  }\n\n  @override\n  Future<EventEntity?> insertCalendar(\n    EventEntity event,\n    LocalPrefEntity pref,\n  ) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    final oauth = googleOAuths.firstWhere((element) => element.email == event.calendarAuthMail);\n    final client = await GoogleApiHandler.getClient(oauth: oauth, scope: scopes);\n\n    try {\n      GoogleCalendar.Event value = await _queue.add(() => GoogleCalendar.CalendarApi(client).events.insert(\n            event.googleEvent!,\n            event.calendarId,\n            sendUpdates: \"all\",\n            conferenceDataVersion: event.conferenceData != null ? 1 : null,\n          ));\n\n      return EventEntity.fromGoogleEvent(\n        calendar: event.calendar,\n        googleEvent: value.copyWith(\n          start: event.googleEvent!.start,\n          end: event.googleEvent!.end,\n        ),\n      );\n    } catch (e) {\n      GoogleApiHandler.checkAuthNotWork(oauth, e.toString(), isCalendar: true);\n      throw e;\n    }\n  }\n\n  @override\n  Future<EventEntity?> updateCalendar(\n    EventEntity event,\n    CalendarEntity? originalCalendar,\n    LocalPrefEntity pref,\n  ) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    final oauth = googleOAuths.firstWhere((element) => element.email == event.calendarAuthMail);\n    final client = await GoogleApiHandler.getClient(oauth: oauth, scope: scopes);\n\n    try {\n      if (originalCalendar != null && originalCalendar.email != event.calendar.email) {\n        await deleteCalendar(event.copyWith(calendar: originalCalendar), pref);\n        EventEntity? value = await insertCalendar(event, pref);\n        return value;\n      } else {\n        GoogleCalendar.Event value = await _queue.add(() => GoogleCalendar.CalendarApi(client).events.update(\n              event.googleEvent!,\n              originalCalendar?.id ?? event.calendarId,\n              event.eventId,\n              alwaysIncludeEmail: true,\n              sendUpdates: \"all\",\n              conferenceDataVersion: 1,\n            ));\n\n        if (event.calendarId != originalCalendar?.id && originalCalendar?.id != null) {\n          value = await _queue.add(() => GoogleCalendar.CalendarApi(client).events.move(\n                originalCalendar!.id,\n                value.id!,\n                event.calendarId,\n              ));\n        }\n\n        return EventEntity.fromGoogleEvent(\n          calendar: event.calendar,\n          googleEvent: value.copyWith(\n            start: event.googleEvent!.start,\n            end: event.googleEvent!.end,\n          ),\n        );\n      }\n    } catch (e) {\n      GoogleApiHandler.checkAuthNotWork(oauth, e.toString(), isCalendar: true);\n      throw e;\n    }\n  }\n\n  @override\n  Future<EventEntity?> deleteCalendar(\n    EventEntity event,\n    LocalPrefEntity pref,\n  ) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    final oauth = googleOAuths.firstWhere((element) => element.email == event.calendarAuthMail);\n    final client = await GoogleApiHandler.getClient(oauth: oauth, scope: scopes);\n    try {\n      await _queue.add(() => GoogleCalendar.CalendarApi(client).events.delete(\n            event.calendarId,\n            event.eventId,\n            sendNotifications: true,\n            sendUpdates: \"all\",\n          ));\n\n      return event;\n    } catch (e) {\n      GoogleApiHandler.checkAuthNotWork(oauth, e.toString(), isCalendar: true);\n      throw e;\n    }\n  }\n\n  void attachCalendarChangeListener({\n    required LocalPrefEntity pref,\n    required UserEntity user,\n    required List<CalendarEntity> calendars,\n  }) async {\n    await detachCalendarChangeListener(pref: pref, calendars: calendars);\n    watchEvents(pref: pref, user: user, calendars: calendars);\n  }\n\n  Future<void> detachCalendarChangeListener({\n    required LocalPrefEntity pref,\n    required List<CalendarEntity> calendars,\n  }) async {\n    await unwatchEvents(pref: pref, calendars: calendars);\n  }\n\n  Future<List<EventEntity>> fetchEventsInCalendar(\n    OAuthEntity oauth,\n    http.Client? client,\n    CalendarEntity calendar,\n    DateTime startDateTime,\n    DateTime endDateTime,\n    String? nextPageToken,\n    LocalPrefEntity pref,\n  ) async {\n    List<EventEntity> events = [];\n    if (client != null) {\n      try {\n        GoogleCalendar.Events value = await GoogleCalendar.CalendarApi(client).events.list(\n              calendar.id,\n              timeMin: startDateTime,\n              timeMax: endDateTime,\n              pageToken: nextPageToken,\n              showHiddenInvitations: true,\n            );\n\n        events.addAll((value.items ?? []).map((e) {\n          String? recurrence = e.recurrence?.where((e) => e.startsWith('RRULE:')).firstOrNull;\n\n          return EventEntity.fromGoogleEvent(\n            googleEvent: e.copyWith(\n              recurrence:\n                  recurrence == null ? null : [Utils.fromGoogleRRule(recurrence, e.start?.date?.toLocal() ?? e.start?.dateTime?.toLocal() ?? DateTime.now())],\n            ),\n            calendar: calendar,\n          );\n        }));\n\n        if (value.nextPageToken != null) {\n          final lazyLoadingResult = await lazyFetchEventsInCalendar(\n            client: client,\n            calendar: calendar,\n            startDateTime: startDateTime,\n            endDateTime: endDateTime,\n            pref: pref,\n            nextPageToken: value.nextPageToken,\n          );\n          events.addAll(lazyLoadingResult);\n        }\n      } catch (e) {\n        GoogleApiHandler.checkAuthNotWork(oauth, e.toString(), isCalendar: true);\n        throw e;\n      }\n    }\n    return events;\n  }\n\n  Future<void> watchEvents({\n    required LocalPrefEntity pref,\n    required List<CalendarEntity> calendars,\n    required UserEntity user,\n  }) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    Map<String, http.Client> clients = {};\n    final authResult = await Future.wait(googleOAuths.map((e) => GoogleApiHandler.getClient(oauth: e, scope: scopes)));\n    for (int i = 0; i < authResult.length; i++) {\n      clients[googleOAuths[i].email] = authResult[i];\n    }\n\n    final configFile = await rootBundle.loadString('assets/config/${F.envFileName}');\n    final env = Environment.fromJson(json.decode(configFile) as Map<String, dynamic>);\n    channels = (await Future.wait(calendars.map(\n            (calendar) => watchCalendar(googleOAuths.firstWhere((o) => o.email == calendar.email), clients, calendar, user, env.googleCalendarWebhookUrl))))\n        .whereType<GoogleCalendar.Channel>()\n        .toList();\n  }\n\n  Future<GoogleCalendar.Channel?> watchCalendar(\n    OAuthEntity oauth,\n    Map<String, http.Client> clients,\n    CalendarEntity calendar,\n    UserEntity user,\n    String webhookUrl,\n  ) async {\n    final client = clients[calendar.email];\n    if (client != null) {\n      try {\n        RegExp regExp = new RegExp(r\"[A-Za-z0-9\\-_\\+/=]+\");\n        final regCalendarId = regExp.allMatches(calendar.id).map((e) => e.group(0)).join('');\n        GoogleCalendar.Channel value = await GoogleCalendar.CalendarApi(client).events.watch(\n              GoogleCalendar.Channel(\n                id: '${user.id.replaceAll('-', '_')}_$regCalendarId',\n                type: \"web_hook\",\n                address: webhookUrl,\n                token: calendar.id,\n                expiration: DateTime.now().add(Duration(days: 30)).millisecondsSinceEpoch.toString(),\n              ),\n              calendar.id,\n            );\n        return value;\n      } catch (e) {\n        GoogleApiHandler.checkAuthNotWork(oauth, e.toString(), isCalendar: true);\n      }\n    }\n    return null;\n  }\n\n  Future<void> unwatchEvents({\n    required LocalPrefEntity pref,\n    required List<CalendarEntity> calendars,\n  }) async {\n    final googleOAuths = (pref.calendarOAuths ?? []).where((element) => element.type == OAuthType.google).toList();\n    Map<String, http.Client> clients = {};\n    final authResult = await Future.wait(googleOAuths.map((e) => GoogleApiHandler.getClient(oauth: e, scope: scopes)));\n    for (int i = 0; i < authResult.length; i++) {\n      clients[googleOAuths[i].email] = authResult[i];\n    }\n\n    calendars = calendars.unique((element) => element.uniqueId);\n    await Future.wait(calendars.map((calendar) => unwatchCalendar(clients, calendar)));\n  }\n\n  Future<void> unwatchCalendar(Map<String, http.Client> clients, CalendarEntity calendar) async {\n    final client = clients[calendar.email];\n    if (client != null) {\n      channels.where((c) => c.token == calendar.id).forEach((element) async {\n        try {\n          // await GoogleCalendar.CalendarApi(client).channels.stop(element);\n        } catch (e) {}\n      });\n      channels.removeWhere((c) => c.token == calendar.id);\n    }\n  }\n\n  @override\n  Future<void> saveReminders({required String userId, required List<CalendarReminderEntity> reminders, required NotificationEntity notification}) async {\n    // only for supabase\n  }\n\n  @override\n  Future<void> cacheCalendarLists({required Map<String, List<CalendarEntity>> calendars}) {\n    throw UnimplementedError();\n  }\n\n  @override\n  Future<void> cacheEventLists({required DateTime startDateTime, required DateTime endDateTime, required List<EventEntity> events}) {\n    throw UnimplementedError();\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/features/calendar/infrastructure/datasources/remote/google_calendar_datasource.dart b/lib/features/calendar/infrastructure/datasources/remote/google_calendar_datasource.dart
--- a/lib/features/calendar/infrastructure/datasources/remote/google_calendar_datasource.dart	(revision 673cc0472510a3c4898d4afc4f6ba3316d0c2fcd)
+++ b/lib/features/calendar/infrastructure/datasources/remote/google_calendar_datasource.dart	(date 1737791545120)
@@ -385,6 +385,7 @@
           events.addAll(lazyLoadingResult);
         }
       } catch (e) {
+        Utils.reportAutoFeedback(errorMessage: 'fetchEventsInCalendar: ${e.toString()}');
         GoogleApiHandler.checkAuthNotWork(oauth, e.toString(), isCalendar: true);
         throw e;
       }
